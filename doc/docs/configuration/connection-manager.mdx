---
sidebar_position: 2
title: Connection Manager
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In Jimmer, all executable statements and instructions support two execution modes:

-   Execute based on the JDBC connection specified by the user  

-   Executed by Jimmer automatically determining based on a JDBC connection

Here, take `Executable` (Java) or `KExecutable` (Kotlin) interface as an example

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Executable.java"
package org.babyfish.jimmer.sql.ast;

import java.sql.Connection;

public interface Executable<R> {

    R execute();

    R execute(Connection con);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="KExecutable.kt" 
package org.babyfish.jimmer.sql.kt

import java.sql.Connection  

interface KExecutable<R> {
  fun execute(con: Connection? = null): R
}
```

</TabItem>
</Tabs>

-   `execute(Connection)`: Execute on the JDBC connection specified by the user.

    Take query as an example:

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java
    BookTable book = BookTable.$;

    List<Book> books = sqlClient
        .createQuery(book)
        .select(book)
        // highlight-next-line
        .execute(con);
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin
    val books = sqlClient
        .createQuery(Book::class) {
            select(table)
        }
        // highlight-next-line
        .execute(con)
    ```

    </TabItem>
    </Tabs>

-   `execute()` or `execute(null)`: Determined by Jimmer to execute on a JDBC connection.

    Take query as an example:

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java
    BookTable book = BookTable.$;

    List<Book> books = sqlClient
        .createQuery(book)
        .select(book)
        // highlight-next-line  
        .execute();
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin
    val books = sqlClient
        .createQuery(Book::class) {
            select(table)
        }
        // highlight-next-line
        .execute()
    ```

    </TabItem>
    </Tabs>

:::info
To use the 1st behavior, no special configuration is required for SqlClient.

To use the 2nd behavior, `ConnectionManager` must be configured for SqlClient. Otherwise it will cause exceptions.

Undoubtedly, the 2nd approach is more in line with the requirements of business system development, so it is recommended. So it is strongly recommended to configure `ConnectionManager` for SqlClient.
:::

## Simple ConnectionManager

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
javax.sql.DataSource dataSource = ...;

JSqlClient sqlClient = JSqlClient
    .newBuilder()
    .setConnectionManager(
        ConnectionManager
        // highlight-next-line
        .simpleConnectionManager(dataSource)
    )
    .builde(); 
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val dataSource: javax.sql.DataSource = ...

val sqlClient = newKSqlClient {
    setConnectionManager {
        ConnectionManager
        dataSoruce.connection.use {
            // highlight-next-line
            proceed(it)
        }
    }
}
```

</TabItem>
</Tabs>

:::danger
This way is only responsible for getting connections from DataSource and has no transaction management mechanism.

However, transactions are very important in actual projects. Therefore, except for learning and trying, it is not recommended to use this approach in actual projects.
:::

## ConnectionManager managed by Spring transaction  

This topic has been discussed in detail in [Spring Section/Integrate Spring Transaction](../spring/transaction). This article will not repeat the explanation.

:::tip
Letting Jimmer be managed by Spring transaction is the recommended usage.
:::
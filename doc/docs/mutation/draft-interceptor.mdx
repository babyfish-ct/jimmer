---
sidebar_position: 6
title: Interceptor
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Premise of This Article

Jimmer supports [triggers](./trigger), including BinLog Triggers and Transaction Triggers.

If using Transaction Triggers, it will cause Jimmer modification operations to generate more complete query statements to simulate triggers.

The various scenarios discussed in this article and their respective generated SQL are all based on the premise of not using Transaction Triggers.

## Define Intercepted Data Format  

Draft interceptors work with [Save Command](./save-command) to adjust data before objects are saved.

If most entity tables have the four fields created_time, modified_time, created_by and modified_by, a super class can be provided as follows:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
// highlight-next-line  
@MappedSuperclass
public interface BaseEntity {

    LocalDateTime createdTime();

    LocalDateTime modifiedTime();

    @ManyToOne
    @OnDissociate(DissociateAction.SET_NULL)
    User creator();

    @ManyToOne
    @OnDissociate(DissociateAction.SET_NULL)
    User editor();
}
```

</TabItem>

<TabItem value="kotlin" label="Kotlin">

```kotlin
// highlight-next-line
@MappedSuperclass
interface BaseEntity {

    val createdTime: LocalDateTime

    val modifiedTime: LocalDateTime

    @ManyToOne
    @OnDissociate(DissociateAction.SET_NULL)
    val createdBy: User

    @ManyToOne
    @OnDissociate(DissociateAction.SET_NULL) 
    val modifiedBy: User
}
```

</TabItem> 
</Tabs>

All entities that need these fields can derive from this superclass.

:::note
The `@OnDissociate(DissociateAction.SET_NULL)` here is to prevent deletion operations on related `User` data from being blocked due to these two foreign keys. When related `User` is deleted, these two foreign keys are automatically cleared.
:::

## Define Interceptor  

Assume there is a service class called `UserService` whose Java method `getCurrentUserId()` or Kotlin property `currentUserId` returns the id of the currently logged in user.

The interceptor must implement the `org.babyfish.jimmer.sql.DraftInterceptor` interface. If using Spring management, the code is:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Component
public class BaseEntityDraftInterceptor implements DraftInterceptor<BaseEntityDraft> {

    private final UserService userService;

    public BaseEntityDraftInterceptor(UserService userService) {
        this.userService = userService;
    }

    @Override
    public void beforeSave(BaseEntityDraft draft, boolean isNew) {
        if (!ImmutableObjects.isLoaded(draft, BaseEntityProps.MODIFIED_TIME)) {
            draft.setModifiedTime(LocalDateTime.now());
        }
        if (!ImmutableObjects.isLoaded(draft, BaseEntityProps.EDITOR)) {
            draft.applyModifiedBy(user -> {
                user.setId(userService.getCurrentUserId());
            });
        }
        if (isNew) {
            if (!ImmutableObjects.isLoaded(draft, BaseEntityProps.CREATED_TIME)) {
                draft.setCreatedTime(LocalDateTime.now());
            }
            if (!ImmutableObjects.isLoaded(draft, BaseEntityProps.CREATOR)) {
                draft.applyCreatedBy(user -> {
                    user.setId(userService.getCurrentUserId());
                });
            }   
        }
    }
}
```

</TabItem>

<TabItem value="kotlin" label="Kotlin">

```kotlin
@Component
class BaseEntityDraftInterceptor(
    private val userService: UserService  
) : DraftInterceptor<BaseEntityDraft> {

    override fun beforeSave(draft: BaseEntityDraft, isNew: Boolean) {
        if (!isLoaded(draft, BaseEntity::modifiedTime)) {
            draft.modifiedTime = LocalDateTime.now()
        }

        if (!isLoaded(draft, BaseEntity::modifiedBy)) {
            draft.modifiedBy().apply {
                id = userService.currentUserId
            }
        }

        if (isNew) {
            if (!isLoaded(draft, BaseEntity::createdTime)) {
                draft.createdTime = LocalDateTime.now()
            }

            if (!isLoaded(draft, BaseEntity::createdBy)) {
                draft.createdBy().apply {
                    id = userService.currentUserId
                }
            }
        }
    }
}
```

</TabItem>
</Tabs>

The `beforeSave` method is called before an object is saved, where the user can make final adjustments to the data to be saved. 

If the `isNew` parameter is true, it means the subsequent operation is an insert; otherwise, it is an update.

:::warning
Please do not modify attributes decorated with `@Id` or `@Key` in the `beforeSave` method.
:::

### Configure Interceptor in Spring

In the above, the class `BaseEntityDraftInterceptor` is decorated with `@Component`, obviously a Spring-managed object.

:::info
If using Spring Boot Starter and ensuring the interceptor is Spring-managed, then Jimmer will register it automatically without additional configuration.

Otherwise, it must be manually registered.
:::

### Configure Interceptor in Low Level API

Attach the interceptor to the SqlClient object to take effect.

## Configure Interceptor

Attaching the interceptor to the SqlClient object makes it take effect:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Bean
public JSqlClient sqlClient(
    List<DraftInterceptor<?>> interceptors,
    ...other params omitted...  
) {
    return JSqlClient
        .newBuilder()
        // highlight-next-line
        .addDraftinterceptors(interceptors)
        ...other config omitted...
        .build();
}
```

</TabItem>

<TabItem value="kotlin" label="Kotlin">

```kotlin 
@Bean  
fun sqlClient(
    interceptors: List<DraftInterceptor<?>>,
    ...other params omitted...
): KSqlClient =
    newKSqlClient {
        // highlight-next-line
        addDraftinterceptors(interceptors)
        ...other config omitted...
    }
```

</TabItem>
</Tabs>

:::tip
Although only one `DraftInterceptor` is demoed in this article, there may be many in an actual project.

So here a collection is used for Spring to inject all `DraftInterceptor` instances.
:::

## Final Usage  

Assume `Book` inherits from `BaseEntity`, then it can be used like:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java  
Book book = BookDraft.$.produce(draft -> {
    draft.setName("SQL in Action");
    draft.setEdition(1);
    draft.setPrice(new BigDecimal("59"));
    draft.applyStore(store -> store.setId(2L));
});
sqlClient.getEntities().save(book);
```

</TabItem>

<TabItem value="kotlin" label="Kotlin">

```kotlin
val book = new(Book::class).by {
    name = "SQL in Action" 
    edition = 1
    price = BigDecimal("59")
    store().id = 2
}
sqlClient.entities.save(book)
```

</TabItem>
</Tabs>

-   If the above save command finally results in an insert operation, the generated SQL is:

    ```sql
    insert into BOOK(
        /* highlight-start */
        CREATED_TIME,
        MODIFIED_TIME, 
        CREATED_BY,
        MODIFIED_BY,
        /* highlight-end */
        NAME,
        EDITION,
        PRICE,
        STORE_ID  
    ) values(
        /* highlight-next-line */
        ?, ?, ?, ?, 
        ?, ?, ?, ?
    )
    ```

    Where the assignment behavior for `CREATED_TIME`, `MODIFIED_TIME`, `CREATED_BY` and `MODIFIED_BY` is automatically added by the interceptor.
    
-   If the above save command finally results in an update operation, the generated SQL is: 

    ```sql
    update BOOK set
        /* highlight-start */
        MODIFIED_TIME = ?, 
        MODIFIED_TIME,
        /* highlight-end */ 
        PRICE = ?,
        STORE_ID = ?
    where ID = ?
    ```
    
    Where the assignment behavior for `MODIFIED_TIME` and `MODIFIED_BY` is automatically added by the interceptor.

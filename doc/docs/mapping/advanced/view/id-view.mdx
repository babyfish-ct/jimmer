---
sidebar_position: 1  
title: IdView
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import { ShortAssociation } from '@site/src/components/ShortAssociation';

## Basic Concepts: Short Associations 

Before introducing IdView, we need to first introduce a concept: short associations.

Before introducing short associations, let's first look at a normal association

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
Book book = bookRepository.findNullable(
    1L,
    BookFetcher.$
        .allScalarFields()
        // highlight-next-line
        .store(
            BookStoreFetcher.$
                .allScalarFields()
        )
        // highlight-next-line
        .authors(
            AuthorFetcher.$
                .firstName()
                .lastName()
        )
);
System.out.println(book);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val book = bookRepository.findNullable(
    1L, 
    newFetcher(Book::class).by {
        allScalarFields()
        // highlight-next-line
        store {
            allScalarFields()
        }
        // highlight-next-line
        authors {
            firstName()
            lastName()
        }
    }
);
System.out.println(book);
```

</TabItem>
</Tabs>

In this code:
-   Fetches associated `BookStore` object via `store` association property of `Book`, expecting to get all non-association properties of associated object
-   Fetches associated `Author` objects via `authors` association property of `Book`, expecting `id` (implicit + mandatory), `firstName` and `lastName` of associated objects

The output is:

```json 
{
    "id":1,
    "name":"Learning GraphQL",  
    "edition":1,
    "price":45,  
    // highlight-next-line
    "store":{
        "id":1,
        "name":"O'REILLY",
        "website":null
    },
    // highlight-next-line 
    "authors":[
        {
            "id":2,
            "firstName":"Alex",
            "lastName":"Banks"
        },
        {
            "id":1, 
            "firstName":"Eve",
            "lastName":"Procello"
        }
    ]
}
```

Here, associated objects `BookStore` and `Author` on aggregate root `Book` have properties other than `id`, with relatively complete information. 

More importantly, non-`id` properties of course also include associated properties, so this data structure can be nested multiple levels or even recursive. This kind of association can also be called a "long association".

:::info
However, not all cases require such a deep data structure. In actual projects, sometimes only a very simple UI is needed, like below:
:::

<ShortAssociation/>

In this UI:

-   `Book.store` is a many-to-one association, rendered as a dropdown selector
-   `Book.authors` is a many-to-many association, rendered as a multiple dropdown selector

> *Of course, if there are too many options, a dropdown list is no longer a reasonable design. In this case, improve it to a popup dialog with pagination. But these UI details are unimportant and irrelevant to the current topic.*

It is obvious that at this point, the user only cares about the `id` of the associated object, and has no interest in other properties of the associated object. 

**That is, we want the associated object to only have the id property** 

To allow aggregate roots to be associated with some objects that only have id, we can improve the code.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java 
Book book = bookRepository.findNullable(
    1L,
    BookFetcher.$
        .allScalarFields()
        // highlight-next-line
        .store() // no args means id only  
        // highlight-next-line
        .authors() // no args means id only
);
System.out.println(book);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val book = bookRepository.findNullable(
    1L,
    newFetcher(Book::class).by {
        allScalarFields()
        // highlight-next-line
        store() // no args means id only
        // highlight-next-line 
        authors() // no args means id only
    } 
);
System.out.println(book);
```

</TabItem>
</Tabs>

This time, we get a data structure like this: 

```json
{
    "id":1,
    "name":"Learning GraphQL",
    "edition":1,
    "price":45,
    "store":{
        // Only has id property  
        // highlight-next-line
        "id":1
    }, 
    "authors":[
        {
            // Only has id property
            // highlight-next-line
            "id":1
        },
        {
            // Only has id property 
            // highlight-next-line
            "id":2
        }
    ]
}
```

:::note
In Hibernate, this kind of object with only id property is called a proxy object. 
:::

However, associated objects with only id are not as simple as just the id of the association. Let's look at the same data expressed with associated ids instead of associated objects:

```json
{
    "id":1, 
    "name":"Learning GraphQL",
    "edition":1,
    "price":45,  
    // highlight-next-line 
    "storeId": 1,
    // highlight-next-line
    "authorIds":[1, 2] 
}
```

It is obvious that for short association use cases, associated ids or their collections are simpler than associated objects or their collections with only id.

## Microsoft's Solution 

`ADO.NET EF Core` is Microsoft's ORM. Let's look at its design: [https://learn.microsoft.com/en-us/ef/core/modeling/relationships?tabs=fluent-api%2Cfluent-api-simple-key%2Csimple-key](https://learn.microsoft.com/en-us/ef/core/modeling/relationships?tabs=fluent-api%2Cfluent-api-simple-key%2Csimple-key)

```csharp
public class Post 
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    // highlight-start
    public int BlogId { get; set; } 
    public Blog Blog { get; set; }
    // highlight-end
}
```

It's easy to see that:

-   Associated object: `public Blog Blog { get; set; }`  
-   Associated id: `public int BlogId { get; set; }`

They coexist.

Jimmer learns from this design of `ADO.NET EF Core` and provides the `@IdView` property.

## IdView Property

### Declaring View Properties

IdView properties are declared with `@org.babyfish.jimmer.sql.IdView`:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
package com.example.model;

import org.babyfish.jimmer.sql.*;
import org.jetbrains.annotations.Nullable;

@Entity
public interface Book {

    ...other properties omitted... 
    
    @ManyToOne  
    @Nullable
    BookStore store();

    @ManyToMany
    @JoinTable(
        name = "BOOK_AUTHOR_MAPPING",
        joinColumnName = "BOOK_ID", 
        inverseJoinColumnName = "AUTHOR_id"
    )
    List<Author> authors();

    // highlight-next-line 
    @IdView // View of store id
    Long storeId();

    // View of all author ids in authors collection
    // highlight-next-line
    @IdView("authors")  
    List<Long> authorIds(); 
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt" 
package com.example.model

import org.babyfish.jimmer.sql.*

@Entity  
interface Book {

    ...other properties omitted...

    @ManyToOne
    val store: BookStore?

    @ManyToMany
    @JoinTable(
        name = "BOOK_AUTHOR_MAPPING",
        joinColumnName = "BOOK_ID",
        inverseJoinColumnName = "AUTHOR_id" 
    )
    val authors: List<Author>

    // highlight-next-line
    @IdView // View of store id
    val storeId: Long? 

    // View of all author ids in authors collection
    // highlight-next-line 
    @IdView("authors")
    val authorIds: List<Long>  
}
```

</TabItem>
</Tabs>

Where: 

-   `Book.storeId`: View of the id of associated `Book.store` object.

    -   Since `storeId` itself ends with `Id`, the parameter of `@IdView` annotation can be omitted. Jimmer infers the original association property to be `Book.store`.

    -   Nullability of original association property and IdView property must be consistent. 

        In this example, `Book.store` property can be null, i.e. annotated with `@Nullable` in Java, or returns `BookStore?` in Kotlin.

        Therefore, `Book.storeId` must also be nullable, i.e. returns `Long` instead of `long` in Java, or returns `Long?` instead of `Long` in Kotlin.

        Otherwise it would cause compile error.

    -   `Book.authorIds`: View of ids of all `Author` objects in associated `Book.authors` collection.

        `authorIds` itself does not end with `Id`, so the parameter of `@IdView` annotation must be specified to explicitly indicate its original association is `Book.authors`.

        > This is required in this case due to irregular noun pluralization in English.

### Essence of View Properties 

The emphasis on the word "view" above is intentional. IdView properties do not have their own data, they are just views of original association properties. 

:::info
IdView properties and original association properties are linked. Setting one necessarily affects the other.
:::

-   Setting view property affects original property:

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java 
    // Set view property
    Book book = BookDraft.$.produce(draft -> {
        draft.setStoreId(10L);
        draft.setAuthorIds(Arrays.asList(100L, 101L)); 
    });

    // Print original property  
    System.out.println("Store: " + book.store());
    System.out.println("Authors:" + book.authors());
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin
    // Set view property
    val book = new(Book::class).by { 
        storeId = 10L
        authorIds = listOf(100L, 101L)
    }

    // Print original property
    println("Store: $book.store}")  
    println("Authors: ${book.authors}")
    ```

    </TabItem>
    </Tabs>

    Prints:

    ```
    Store: {"id":10}
    Authors: [{"id":100},{"id":101}]
    ```

-   Setting original property affects view property:

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java
    // Set original property
    Book book = BookDraft.$.produce(draft -> {
        draft.applyStore(store -> {
            store.setId(10L).storeName("TURING")  
        });
        draft.addIntoAuthors(author -> {
            author.setId(101L);
            author.setFirstName("Fabrice");
            author.setLastName("Marguerie"); 
        });
        draft.addIntoAuthors(author -> {
            author.setId(101L);
            author.setFirstName("Steve");
            author.setLastName("Eichert");  
        });
    });

    // Print view property
    System.out.println("StoreId: " + book.storeId()); 
    System.out.println("AuthorIds:" + book.authorIds());
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin 
    // Set original property
    val book = new(Book::class).by {
        store().apply { 
            id = 10L
            name = "TURING"
        }
        authors().addBy {
            id = 101L;
            firstName = "Fabrice"
            lastName = "Marguerie"
        }
        authors().addBy {
            id = 101L  
            firstName = "Steve"
            lastName = "Eichert"  
        }
    }

    // Print view property
    println("Store: $book.storeId}")
    println("Authors: ${book.authorIds}") 
    ```

    </TabItem>
    </Tabs>

    Prints:

    ```
    StoreId: 10
    AuthorIds: [100, 101] 
    ```

:::tip
This shows that view properties and original properties are highly unified. Jimmer is still a ORM framework that is core-associated-object-oriented. View properties are just syntactic sugar.

Except for the impact on object fetchers to be explained below, view properties do not affect ORM and core logic at all.
:::  

## Fetching IdView Properties  

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java  
Book book = bookRepository.findNullable(
    1L,
    BookFetcher.$
        .allScalarFields()
        // highlight-next-line  
        .storeId()
        // highlight-next-line
        .authorIds()
);
System.out.println(book);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val book = bookRepository.findNullable(
    1L,
    newFetcher(Book::class).by {
        allScalarFields() 
        // highlight-next-line
        storeId()
        // highlight-next-line
        authorIds()
    }
);
System.out.println(book); 
```

</TabItem>
</Tabs>

Prints:

```json
{
    "id":1,
    "name":"Learning GraphQL",
    "edition":1,
    "price":45,
    // highlight-next-line
    "storeId": 1,  
    // highlight-next-line
    "authorIds":[1, 2]
}
```

:::tip
For Jimmer dynamic entities, original association properties and view properties are absolutely consistent. Either both can be accessed, or both are missing.

Whether choosing to fetch the original association property or choosing to fetch the IdView view property does not affect the underlying execution logic of Jimmer, including the ultimately generated SQL. 

The only difference brought by different choices is that the Jackson visibility flags of original association properties and view properties are different.

That is, properties fetched directly will be serialized by Jackson, while properties not fetched directly will be ignored.
:::

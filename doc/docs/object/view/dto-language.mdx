---
sidebar_position: 1
title: DTO Language
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { ShortAssociation } from '@site/src/components/ShortAssociation';
import FlatProblem from './_flat-problem.md';
import { ViewMore } from '@site/src/components/ViewMore';

## 1. Concepts

### 1.1. Pain Point

Jimmer provides dynamic entities that can solve a large part of the DTO explosion problem very well. Therefore, generally speaking, it is not necessary to define output DTO types to express query results. 

However, not all DTO types can be eliminated. Input DTO objects are hard to remove.

> For example, in GraphQL, although dynamic `GraphQLObject` data is returned for the client from the output perspective, static `GraphQLInput` data submitted by the client is accepted from the input perspective.
>
> Why does the GraphQL protocol define `GraphQLInput` as a static type? Because API explicitness and system security are very important requirements, please refer to [Problems with dynamic objects as input parameters](../../mutation/save-command/input-dto/problem).
>
> The problems faced by the GraphQL protocol are also faced by Jimmer, which must provide a complete solution.

:::tip
The DTO language is designed for that part of the DTO types that cannot be eliminated, with the goal of making them extremely cheap.
:::

### 1.2. Solution

As a comprehensive solution, Jimmer is not limited to ORM itself, but considers the whole project. To solve this problem, it provides the DTO language.

The DTO language is a very powerful feature provided by Jimmer, and is a concept highly similar to [Object Fetcher](../../query/object-fetcher), but at an earlier stage during compilation.

The DTO language is used to quickly define the shape of data structures. Based on these shapes, DTOs can be compile-time

-   Generate specific static DTO types corresponding to specific data structures

-   Generate mutual conversion logic between DTO static objects and Jimmer dynamic objects

-   Generate [Object Fetchers](../../query/object-fetcher) that match perfectly with the DTO shape definitions

Using the DTO language to quickly build DTO types is a solution tailored for Jimmer with extremely high development efficiency, much faster than using [mapstruct](./mapstruct), and is the recommended approach.

### 1.3. Application Scenarios

The application scenarios of the DTO language:

-   [Serve as return results in query APIs *(optional, not recommended, don't use unnecessarily)*](../../query/object-fetcher/dto) 

-   [Serve as input parameters in save APIs *(required)*](../../mutation/save-command/input-dto/dto-lang)

-   [Serve as input parameters in super QBE queries *(optional, recommended)*](../../query/super_qbe)

## 2. Create File

The code of the DTO language is reflected in files with the extension `dto`. Once compilation is complete, these files have no value. So these files cannot be packaged into `src/main/resources`, but should be placed in the `src/main/dto` directory.

Therefore, the first thing is to create a `dto` subdirectory under `src/main`.  

:::tip
Jimmer does not require the `src/main/dto` directory to be in the project where the entity type is located. In fact, you can create this directory in any project that can legally access the entity.

Jimmer only requires using `jimmer-apt` or `jimmer-ksp` in projects containing dto files. They are responsible for compiling dto files and generating related code.

> For Java projects, in addition to `jimmer-apt`, it may be necessary to add an extra configuration. Please refer to [Notes](#22-notes).
:::

### 2.1. Two ways to create files

Multiple dto files can be defined under the `src/main/dto` directory, with each file corresponding to an original entity.

Assuming there is a Jimmer entity type whose full type name is `com.yourcompany.yourproject.Book`, and this class is decorated with `@org.babyfish.jimmer.sql.Entity` *(DTO language only supports Entity types)*, there are two ways to create dto files.

1.  When `export` statement is not used

    In this case, the dto file directory needs to correspond to the original entity package, and the name needs to correspond to the original entity name:

    1.  Under the `src/main/dto` directory, create the directory `com/yourcompany/yourproject`, that is, create a directory consistent with the package name

    2.  In the directory created in the previous step, create a new file `Book.dto`. This file must have the same name as the class and have the extension `dto`

2.  When `export` statement is used

    In this case, the dto file directory and name are arbitrary, because we will use the `export` statement inside the file to define which original entity the dto file corresponds to.

    -   Since there is no requirement for the dto file directory, it is recommended to create the dto file directly under `src/main/dto`

    -   Although there is no requirement for the dto file name either, for the maintainability of the project, it is still recommended that the file name adopts the name of the original entity, which is `Book.dto` in this case

    -   The first line of code in the dto file is the `export` statement

        ```sh
        export com.yourcompany.yourproject.Book

        ...subsequent code...
        ```

After the DTO file is compiled, more Java/Kotlin types will be generated automatically. Their default package name is: `entity package name` + `.dto`.  

If you use the `export` statement, you can further define the package where the generated code is located, for example:

```sh
export com.yourcompany.yourproject.Book
    -> package com.yourcompany.yourproject.mydto 
```

Users can edit the `Book.dto` file to define any number of DTO types with `Book` as the aggregate root. Here we first define a DTO type:

```sh title="Book.dto"
...export statement omitted if any...

BookView {
    ...omitted...
}
``` 

:::info
The first line of code in the dto file may be the `export` statement. For simplicity, export statements are omitted in subsequent sections.
:::

After compilation, the Java/Kotlin type `BookView` will be generated. Assuming the default value of the package where the generated code is located has not been changed, the generated code is as follows:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookView.java"
package com.yourcompany.yourproject.dto;

import com.yourcompany.yourproject.Book;
import org.babyfish.jimmer.View;

public class BookView implements View<Book> {
    ...omitted...
} 
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookView.kt"  
package com.yourcompany.yourproject.dto

import com.yourcompany.yourproject.Book
import org.babyfish.jimmer.View

data class BookView(
    ...omitted...
) : View<Book> {
    ...omitted...
}
```

</TabItem>
</Tabs>

### 2.2. Notes  

:::warning
- For Java projects *(Kotlin developers please ignore)*:

  If the current project is not the project that defines the entity, you need to decorate any class in the current project with `@org.babyfish.jimmer.sql.EnableDtoGeneration`.

  Otherwise, the DTO file will not be compiled.

- dto files are compiled by Jimmer's Annotation Processor *(Java)* or Ksp *(Kotlin)*.

  Therefore, if you are using an IDE like Intellij to develop projects, then

    - In addition to dto files, if other Java/Kotlin files are modified, clicking the run button in the IDE directly can cause recompilation of dto files

    - However, if no other Java/Kotlin files are modified except dto files, simply clicking the run button in the IDE does not cause dto files to be recompiled unless explicitly rebuilding!
:::

## 3. view, input and specification  

It was mentioned earlier that the DTO language has three use cases:

-   [Serve as return values in query APIs *(optional, not recommended, don't use unnecessarily)*](../../query/object-fetcher/dto)

-   [Serve as input parameters in save APIs *(required)*](../../mutation/save-command/input-dto/dto-lang) 

-   [Serve as input parameters in super QBE queries *(optional, recommended)*](../../query/super_qbe)

So, the DTO language can define three types of DTOs:

-   view: Neither uses the `input` keyword nor the `specification` keyword, which can be understood as Output DTO.

-   input: Declared with the `input` keyword, which can be understood as Input DTO.

-   specification: Declared with the `specification` keyword. It is not closely related to DTO itself, but can be used as a query parameter to support [super QBE queries](../../query/super_qbe).

```sh title="Book.dto"
BookView {
    ...omitted...
}

AnotherBookView {
   ...omitted...
}

input BookInput {
    ...omitted... 
}

input AnotherBookInput {
    ...omitted...
}

specification BookSpecification {
    ...omitted...
} 

specification AnotherBookSpecification {
    ...omitted...
}
```

This means:

-   `BookView` and `AnotherBookView` are used as query outputs. The generated Java/Kotlin types implement the `org.babyfish.jimmer.View<E>` interface

    :::note
    It is recommended that output DTOs end with `View`
    :::

-   `BookInput` and `AnotherBookInput` are used as save command inputs. The generated Java/Kotlin types implement the `org.babyfish.jimmer.Input<E>` interface

    :::note 
    It is recommended that input DTOs end with `Input`
    :::

-   `BookSpecification` and `AnotherBookSpecification` are used as query parameters to support [super QBE queries](../../query/super_qbe). The generated Java/Kotlin types implement the `org.babyfish.jimmer.Specification<E>` interface

    :::note
    It is recommended that query parameter DTOs end with `Specification`
    :::

### 3.1 Common functionalities of view and input

For view and input, their generated Java/Kotlin types can convert between entities, with the following capabilities:

-   Constructor taking original entity type as parameter: Convert Jimmer dynamic entity object to static DTO object

-   `toEntity()`: Convert static DTO object to Jimmer dynamic entity object

Take `BookView` as an example:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
Book entity = ...omitted...;

// Entity -> DTO
BookView dto = new BookView(entity);

// DTO -> Entity
Book anotherEntity = dto.toEntity();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
val entity: Book = ...omitted...

// Entity -> DTO
val dto = BookView(entity)

// DTO -> Entity
val anotherEntity: Book = dto.toEntity()
```

</TabItem>
</Tabs>

### 3.2 input-specific functionalities 

Compared with Output DTO, Input DTO has the following differences:

-   If the entity ID property is configured with auto-increment strategy, the id property in the input DTO is nullable.

-   The input DTO can only define savable properties, such as simple properties, ordinary ORM associations, and id-view properties. Unsavable properties such as transient properties, formula properties, computed properties, and remote associations cannot be defined, otherwise it will cause compilation errors.

### 3.3 specification-specific functionalities

The role of `specification` is similar to `input`, used to decorate input types, but `specification` does not provide the ability to convert between entity objects, but is used as a query parameter to support [super QBE queries](../../query/super_qbe). 

:::tip
[Super QBE Query](../../query/super_qbe) is a very powerful feature of Jimmer that is not explained here. Please refer to the [relevant section](../../query/super_qbe).
:::

## 4. Simple properties

Attributes can be defined for DTO types to map properties in the original entity type, for example:

```sh title="Book.dto"
BookView {
    id
    name
    edition
} 
```

This means that the DTO only maps the three properties of the entity: `id`, `name` and `edition`, as follows:

<Tabs groupId="language">
<TabItem value="java" label="Java">  

```java title="BookView.java"
public class BookView implements View<Book> {

    private long id;
    private String name;
    private String edition;

    public BookView(Book book) {
        ...omitted...
    }

    @Override
    public Book toEntity() {
        ...omitted...
    }

   ...other members omitted...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookView.kt"
data class BookView(
    val id: Long = 0, 
    val name: String = "",
    val edition: Int = 0  
) : View<Book> {

    constructor(book: Book): this(...omitted...)

    override fun toEntity(): Book {
        ...omitted...
    }

   ...other members omitted...
}
```

</TabItem> 
</Tabs>

## 5. allScalars

The DTO language supports a special macro property, `#allScalars`, which represents mapping all scalar properties in the entity.

```sh title="Book.dto"
BookView {
    #allScalars
}
```

According to the definition of the `Book` type in the official example:

-   The scalar properties of `Book` itself are `id`, `name`, `edition`, and `price` 

-   `Book` inherits `TenantAware`, and the `TenantAware` interface defines the `tenant` property

-   `Book` also inherits `CommonEntity` *(multiple inheritance)*, and `CommonEntity` interface defines the `createdTime` and `modifiedTime` properties

`#allScalars` means automatically mapping all scalar properties of the entity, including inherited ones. 

If this is not the behavior you want, then

-   You can use `allScalars(Book)` to indicate mapping only the scalar properties defined by the Book type itself, excluding inherited properties.

-   You can also use `allScalars(TenantAware)` and `allScalars(CommonEntity)` to indicate properties of specific super types. 

:::tip
For the current type `Book`, `#allScalars(Book)` can also be written as `#allScalars(this)`.
:::

In fact, `#allScalars` supports multiple parameters, for example:

|Macro Expression|Automatically Mapped Attributes|
|-|-|
|#allScalars|createdTime, modifiedTime, tenant, id, name, edition, price|
|#allScalars(this)|id, name, edition, price| 
|#allScalars(TenantAware)|tenant|
|#allScalars(CommonEntity)|createdTime, modifiedTime|
|#allScalars(this, TenantAware)|tenant, id, name, edition, price|
|#allScalars(this, CommonEntity)|createdTime, modifiedTime, id, name, edition, price|
|#allScalars(TenantAware, CommonEntity)|createdTime, modifiedTime, tenant| 
|#allScalars(this, TenantAware, CommonEntity)|createdTime, modifiedTime, tenant, id, name, edition, price|

:::info
-   If the `#allScalars` macro is used, it must be defined as the first property, otherwise it will cause compile errors.

-   If parameters are specified for the `#allScalars` macro, each parameter must be the current entity or its base type, otherwise it will cause compile errors.
:::

## 6. Negative Attributes  

The `#allScalars` macro mentioned above will batch map multiple properties. Negative properties can remove some properties.

```sh title="Book.dto"  
BookView {
    #allScalars
    // highlight-next-line  
    -tenant
}
```

Similar to above, if we understand according to the inheritance relationship of the `Book` type in the official example, `#allScalars` will add the properties `createdTime`, `modifiedTime`, `tenant`, `id`, `name`, `edition` and `price`. 

`-tenant` removes the `tenant` property from it, finally adding the properties `createdTime`, `modifiedTime`, `id`, `name`, `edition` and `price`.

:::info
What is specified by the negative property is not the property name of the entity, but the name of the corresponding property in the DTO. Here the two are the same and there is no difference. 

The [Renaming](#8-renaming) section later will reveal the difference between the two.
:::

It is not difficult to find that for this example, there is another equivalent writing:

```sh title="Book.dto" 
BookView {
    // Exclude `TenantAware`
    #allScalars(Book, CommonEntity)
} 
```

## 7. Nullability

By default:

-   All properties in `specification` are null by default. 

-   Otherwise, the nullability of DTO properties is the same as the nullability of original properties in entities.

We can use `?` or `!` to modify DTO properties to change the nullability of DTO properties.

### 7.1. `?`  

We can use `?` to modify DTO properties to make them nullable. 

:::warning
If the original property in the entity is already nullable, it will cause compile errors.
:::

For example:

```sh title="Book.dto"
input UpdateBookInput { 
    #allScalars
    // highlight-next-line
    price?
}
```

You can even apply `?` to `allScalars` to make all automatically mapped non-associative properties nullable:

```sh title="Book.dto" 
input UpdateBookInput {
    // highlight-next-line  
    #allScalars? 
}
```

-   Specification types do not allow `?`

    :::warning
    Since all properties in `speciciation` are nullable by default, specifying the modifier `?` for properties within `specification` will cause compile errors.
    :::

-   When the original property in the entity does not allow null

    For non-nullable original properties in an entity, if the corresponding property in the DTO object is null, the original property in the entity object will not be assigned after converting the DTO object to the entity object. 

-   When the original property in the entity allows null

    For originally nullable properties in entities, if the corresponding property in the DTO object is null, then when converting the DTO object to the entity object:

    - If the `input` type is not modified by the `dynamic` keyword, the original property in the entity object will be assigned to null.

    - If the `input` type is modified by the `dynamic` keyword, for example:

        ```sh title="BookStroe.dto" 
        #highlight-next-line
        dynamic input BookInput {
            #allScalars(this)?
        }
        ```

        The original properties in the entity object will not be assigned.

### 7.2. `!`

We can use `!` to modify DTO properties to make them non-null.

:::warning 
If the original property in the entity is already non-null, it will cause compile errors.
:::

Its use is limited and can only be used in the following three cases:

-   Modify the id property in `input` type

    If the id property is configured with auto-increment strategy, the corresponding input DTO type will make the id property nullable.

    However, this behavior does not always meet user expectations. You can use `!` to modify the id property in the `input` type to make it non-null, for example:

    ```sh  title="Book.dto"
    input BookUpdateInfo {
        #allScalars 
        #highlight-next-line
        id!
    }
    ```

    :::warning
    Using `?` to modify other properties will cause compile errors.
    :::

-   If `input` is modified by the `unsafe` keyword, any nullable entity property can be converted to non-null, for example:

    ```sh  title="Book.dto"
    unsafe input BookUpdateInfo {
        #allScalars
        #highlight-next-line
        store! {
            ...omitted...
        }
    }
    ```

    :::info
    For an entity object, if the corresponding value of this property is null, when using the Input DTO constructor to convert it to an Input DTO object, an exception will occur because the corresponding property in DTO does not allow null.

    This is the meaning of the `unsafe` keyword.
    :::

-   For `specification`, since all properties are null by default, any nullable entity property can be converted to non-null, for example:

    ```sh  title="Book.dto"
    specification BookSpecification {
        #allScalars
        #highlight-next-line
        edition!
    }
    ```

## 8. Renaming  

The `as` keyword can be used to set aliases for properties so that entity property names are different from DTO property names.

`as` has two usages, it can precisely set an alias for a single property, and it can also vaguely set aliases for multiple properties.

### 8.1. Renaming a single property

```sh title="Book.dto" 
BookView {
    name as bookName
}
```

### 8.2. Renaming multiple properties

Assume there is an entity type called `Robot`:

```sh title="Robot.dto"
OrderView {
    as (^ -> oldSystem) { ❶
        prop1
        prop2 
    }
    as ($ -> ForNewSystem) { ❷
        prop3
        prop4
    }
}
```

Where:

-   ❶ Adds the prefix `oldSystem` to `prop1` and `prop2`, where `^` indicates the start position

-   ❷ Adds the suffix `ForNewSystem` to `prop3` and `prop4`, where `$` indicates the start position

The generated `RobotView` class is as follows:

<Tabs groupId="language">
<TabItem value="java" label="Java">  

```java title="BookView.java" 
public class RobotView implements View<Robot> {

    private String oldSystemProp1;
    private String oldSystemProp2;

    private String prop3ForNewSystem;
    private String prop4ForNewSystem;

   ...other members omitted...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookView.kt"
data class RobotView(
    
    val oldSystemProp1 = "",
    val oldSystemProp2 = "",

    val prop3ForNewSystem = "",
    val prop4ForNewSystem = ""  
) : View<Robot> {

   ...other members omitted...
}
```

</TabItem>
</Tabs>

You can define most properties in the `as() {...}` block, of course including `#allScalars`, for example: 

```sh title="Robot.dto"
RobotView {
    # highlight-next-line
    as(^ -> robot) {
        # highlight-next-line 
        #allScalars
    }
}
```

Below are all the usages of the `as() {...}` block:

|Code Example|Description| 
|-|-|
|as(^ -> prefix)|Add prefix|
|as(^prefix ->)|Remove prefix| 
|as(^prefix -> newPrefix)|Replace prefix|
|as($ -> suffix)|Add suffix|
|as($suffix ->)|Remove suffix|
|as($suffix -> newSuffix)|Replace suffix|
|as(infix -> )|Remove any content|
|as(infix -> newInfix)|Replace any content|

:::caution
`^` and `$` cannot appear at the same time, because it means precise renaming of a single property, which duplicates existing functionality. 
:::

## 9. Enum Mapping  

By default, enum type properties in entities are still enum types after being mapped to DTO properties.

You can map enum types to numbers or strings:

-   Map to numbers

    ```sh
    AuthorView {
        #allScalars
        gender -> {
            MALE: 100
            FEMALE: 101
        }
    }
    ```

    The following code will be generated:

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java title="BookView.java" 
    public class AuthorView implements View<AuthorView> {

        private int gender;

        ...other members omitted...
    }
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin title="BookView.kt"
    data class RobotView(
        val gender: Int,
        ...other members omitted...
    ) : View<Robot> {

        ...other members omitted...
    }
    ```

    </TabItem>
    </Tabs>

-   Map to strings

    ```sh 
    AuthorView {
        #allScalars
        gender -> {
            MALE: "Male" 
            FEMALE: "Female"
        }
    }
    ```

    The following code will be generated:

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java title="BookView.java"
    public class AuthorView implements View<AuthorView> {

        private String gender;

        ...other members omitted...
    }
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin title="BookView.kt"
    data class RobotView(
        val gender: String,
        ...other members omitted... 
    ) : View<Robot> {

        ...other members omitted...
    }
    ```

    </TabItem>
    </Tabs>

## 10. Association Attributes  

The handling of association properties is a very powerful feature of the DTO language with three usages:

-   Direct use
-   Recursive association
-   Call id function
-   Call flat function

### 10.1. Ordinary Association

-   Basic usage

    ```sh title="Robot.dto"
    input CompositeBookInput {
        
        #allScalars(Book)

        # highlight-next-line  
        store {
            #allScalars(BookStore)
            -id
        }

        # highlight-next-line
        authors {
            #allScalars(Author)
            -id
        }
    }
    ```

    The generated code is:

    <Tabs groupId="language">
    <TabItem value="java" label="Java">

    ```java title="CompositeBookInput.java" 
    public class CompositeBookInput implements Input<Book> {

        @Nullable
        private Long id;

        private String name;

        private int edition;

        private BigDecimal price;

        // highlight-next-line
        private TargetOf_store store;

        // highlight-next-line
        private List<TargetOf_authors> authors;

        // highlight-next-line
        public static class TargetOf_store implements Input<BookStore> {
        
            private String name;

            @Nullable
            private String website;

            ...other members omitted...
        }

        // highlight-next-line
        public static class TargetOf_authors implements Input<Author> {
            
            private String firstName;

            private String lastName;

            private Gender gender;

            ...other members omitted...
        }

        ...other members omitted...
    }
    ```

    </TabItem>
    <TabItem value="kotlin" label="Kotlin">

    ```kotlin title="CompositeBookInput.kt"
    data class CompositeBookInput(
        val id: Long? = null,
        val name: String = "",
        val edition: Int = 0, 
        val price: BigDecimal,

        // highlight-next-line
        val store: TargetOf_store? = null,
        // highlight-next-line
        val authors: List<TargetOf_authors> = emptyList(),
    ) : Input<Book> {

        // highlight-next-line
        data class TargetOf_store(
            val name: String = "",
            val website: String? = null,
        ) : Input<BookStore> {
            ...other members omitted...
        }

        // highlight-next-line
        data class TargetOf_authors(
            public val firstName: String = "",
            public val lastName: String = "",
            public val gender: Gender,
        ) : Input<Author> {
            ...other members omitted...
        }

        ...other members omitted...
    }
    ```

    </TabItem>
    </Tabs>

-   Renaming

    If you want to rename association properties, the `as` clause should be before the association definition block, for example:

    ```sh title="Book.dto"
    input CompositeBookInput {
        
        authors as authorList {
            ...omitted...
        }

        ...omitted...
    }
    ```

### 10.2 Recursive Association  

For recursively associative properties in entities, such as `TreeNode.parent` or `TreeNode.childNodes` in the attached example, the corresponding associative property in the DTO can be marked as recursive using an asterisk `*`.

```sh title="TreeNode.dto" 
TreeNodeView {
    
    #allScalars

    childNodes {
        #allScalars
    #highlight-next-line
    }*
}
```

### 10.3. id Function  

For <ViewMore buttonText="short associations"><ShortAssociation/></ViewMore>, we certainly choose to define [@IdView](../../mapping/advanced/view/id-view) properties in entities, for example:

<Tabs groupId="language">
<TabItem value="java" label="Java">  

```java title="Book.java"
@Entity
public interface Book {

    @Nullable
    @ManyToOne  
    BookStore store();

    @ManyToMany
    val authors: List<Author>

    // highlight-next-line
    @IdView    
    Long storeId();

    // highlight-next-line
    @IdView("authors")
    List<Long> authorIds();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt" 
@Entity
interface Book {

    @ManyToOne
    val store: BookStore?

    @ManyToMany
    val authors: List<Author>
    
    // highlight-next-line
    @IdView     
    val storeId: Long?

    // highlight-next-line
    @IdView("authors")
    val authorIds: List<Long>
}
``` 

</TabItem>
</Tabs>

In cases where the entity has already defined [@IdView](../../mapping/advanced/view/id-view) properties, you only need to simply reference them in the DTO language:

```sh title="Book.dto"
BookView {

    // highlight-next-line
    storeId

    // highlight-next-line
    authorIds

    ...omitted...
} 
```

:::tip  
However, we cannot always rely on entity types to declare [@IdView](../../mapping/advanced/view/id-view) properties. A better solution should not have this assumption. 

Therefore, the DTO language supports calling the `id` function on association properties to achieve the same purpose.
:::

```sh title="Book.dto"
BookView {

    // highlight-next-line
    id(store)

    // highlight-next-line
    id(authors) as authorIds

    ...omitted...
}
```

This code has the exact same function as the previous example, but no longer assumes the entity type always declares [@IdView](../../mapping/advanced/view/id-view) properties, which is a better solution.

### 10.4. flat Function  

-   For view and input, the `flat` function can only be used for referential associations *(one-to-one or many-to-one)*, not collection associations *(one-to-many or many-to-many)*. It is used to promote the properties of associated DTOs to the current DTO type to obtain a flattened object without associations.

-   For sepecification, the `flat` function does not have the above restrictions and can be used for collection associations. Please check (../../query/super_qbe).

Take the `TreeNode` entity in the official example *(in fact, this example is wrong, we will discuss this issue later)*:

```sh title="TreeNode.dto"
FlatTreeNodeView {
    
    #allScalars(TreeNode)

    # highlight-next-line
    flat(parent) {
        #allScalars(TreeNode)
    }
} 
```

As mentioned above, this example is wrong, because the aggregate root and the associated object both have the `id` and `name` properties. Unconditionally extracting the properties of the associated object to the aggregate root will inevitably lead to name conflicts, eventually causing DTO language compilation errors.

The right approach is to combine it with the user's multi-property fuzzy renaming `as(...) {}` block. Let's look at a new example:

```sh title="TreeNode.dto"
FlatTreeNodeView {
    
    #allScalars(TreeNode) // id, name

    # highlight-next-line
    flat(parent) {
        # highlight-next-line
        as(^ -> parent) {
            // parentId, parentName
            #allScalars(TreeNode)
        }
    }
}
```

Thus, we get a flattened DTO type with 4 properties: `id`, `name`, `parentId` and `parentName`. 

You can even nest the `flat` function to convert multi-level associations into flattened objects:

```sh title="TreeNode.dto"
FlatTreeNodeView {
    
    #allScalars(TreeNode)

    # highlight-next-line
    flat(parent) {
        as(^ -> parent) {
            #allScalars(TreeNode)
        }
        # highlight-next-line
        flat(grandParent) {
            as(^ -> parent) {
                #allScalars(TreeNode)
            }
            
        }   
    }
} 
```

Thus, we get a flattened DTO type with 6 properties: `id`, `name`, `parentId`, `parentName`, `grandParentId`, and `grandParentName`.

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
TreeNode treeNode = treeNodeDraft.$.produce(cola -> {
    cola.setId(4L);
    cola.setName("Coca cola");
    cola.applyParent(drinks -> {
        drinks.setId(3L);
        drinks.setName("Drinks");
        drinks.applyParent(food -> {
            food.setId(2L);
            food.setName("Food");
        })
    })
});

// Convert hierarchical Entity to flattened DTO  
FlatTreeNodeView view = new FlatTreeNodeView(treeNode);  

System.out.println(view);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
val treeNode = new(TreeNode::class).by {
    id = 4L
    name = "Coca cola"
    parent().apply {
        id = 3L
        name = "Drinks"
        parent().apply {
            id = 2L
            name = "Food"
        }   
    }
}

// Convert hierarchical Entity to flattened DTO
val view = FlatTreeNodeView(treeNode)

println(view) 
```

</TabItem>
</Tabs>

The print result is *(formatted here for readability)*:

```
com.yourcompany.yourproject.FlatTreeNodeView(
    id = 4,
    name = Coco cola, 
    parentId = 3,
    parentName = Drinks,
    grandParentId = 2,
    grandParentName = "Food"
)
```

The `flat` solution also has drawbacks. For **output** DTOs, the `flat` solution is controversial and is not recommended to be blindly adopted.

Please refer to <ViewMore buttonText="Controversy over whether output DTOs should use flat mode"><FlatProblem/></ViewMore>

## 11. Custom Fields

### 11.1 Introduction to Custom Fields

In the examples we have discussed before, all DTO properties are mapped from entity properties and become mapped properties.

In addition to mapped properties, DTO types also support mapping custom properties:

```sh title="BookInput.dto"  
BookInput {
    
    #allScalars(Author)? - id

    #highlight-next-line
    remark: String
}
```

Here, `BookInput` has a custom field `remark`.

:::info
The difference between custom properties and mapped properties is that custom properties require type definitions. 
:::

### 11.2 Built-in Types  

Custome fields can be defined as built-in types, which are types built into the DTO language that do not require import via `import`.

-   Primitive and boxed types

    |DTO Language Type|Generated Java Type|Generated Kotlin Type|
    |-|-|-|
    |Boolean|boolean|Boolean|
    |Boolean?|Boolean|Boolean?|
    |Char|char|Char|
    |Char?|Character|Char?|  
    |Byte|byte|Byte|
    |Byte?|Byte|Byte?|
    |Short|short|Short|
    |Short?|Short|Short?|
    |Int|int|Int|
    |Int?|Integer|Int?|
    |Long|long|Long|
    |Long?|Long|Long?|
    |Float|float|Float|
    |Float?|Float|Float?|
    |Double|double|Double|
    |Double?|Double|Double?|

-   Any and String types

    |DTO Language Type|Generated Java Type|Generated Kotlin Type|
    |-|-|-|
    |Any|Object|Any|  
    |String|String|String|

-   Array types

    |DTO Language Type|Generated Java Type|Generated Kotlin Type|
    |-|-|-|
    |Array&lt;Boolean&gt;|boolean[]|BooleanArray|
    |Array&lt;Boolean?&gt;|Boolean[]|Array&lt;Boolean?&gt;|
    |Array&lt;Char&gt;|char[]|CharArray|
    |Array&lt;Char?&gt;|Character[]|Array&lt;Char?&gt;|
    |Array&lt;Byte&gt;|byte[]|ByteArray|
    |Array&lt;Byte?&gt;|Byte[]|Array&lt;Byte?&gt;|
    |Array&lt;Short&gt;|short[]|ShortArray| 
    |Array&lt;Short?&gt;|Short[]|Array&lt;Short?&gt;|
    |Array&lt;Int&gt;|int[]|IntArray|
    |Array&lt;Int?&gt;|Integer[]|Array&lt;Int?&gt;|
    |Array&lt;Long&gt;|long[]|LongArray|
    |Array&lt;Long?&gt;|Long[]|Array&lt;Long?&gt;|
    |Array&lt;Float&gt;|float[]|FloatArray|
    |Array&lt;Float?&gt;|Float[]|Array&lt;Float?&gt;|
    |Array&lt;Double&gt;|double[]|DoubleArray|
    |Array&lt;Double?&gt;|Double[]|Array&lt;Double?&gt;|
    |Array&lt;UserType&gt;|UserType[]|Array&lt;UserType&gt;|
    |Array&lt;UserType?&gt;|UserType[]|Array&lt;UserType?&gt;|
    |Array&lt;*&gt;|Object[]|Array&lt;*&gt;|

-   Collection types

    |DTO Language Type|Generated Java Type|Generated Kotlin Type|
    |-|-|-|
    |Iterable&lt;E&gt;|Iterable&lt;? extends E&gt;|Iterable&lt;E&gt;|
    |MutableIterable&lt;E&gt;|Iterable&lt;E&gt;|MutableIterable&lt;E&gt;|
    |Collection&lt;E&gt;|Collection&lt;? extends E&gt;|Collection&lt;E&gt;|
    |MutableCollection&lt;E&gt;|Collection&lt;E&gt;|MutableCollection&lt;E&gt;|
    |List&lt;E&gt;|List&lt;? extends E&gt;|List&lt;E&gt;|
    |MutableList&lt;E&gt;|List&lt;E&gt;|MutableList&lt;E&gt;|
    |Set&lt;E&gt;|Set&lt;? extends E&gt;|Set&lt;E&gt;|
    |MutableSet&lt;E&gt;|Set&lt;E&gt;|MutableSet&lt;E&gt;|  
    |Map&lt;K, V&gt;|Map&lt;? extends K, ? extends V&gt;|Map&lt;K, V&gt;|
    |MutableMap&lt;K, V&gt;|Map&lt;K, V&gt;|Mutable&lt;K, V&gt;|

### 11.3 Generic Parameter Modifiers

Except for generic class types *(arrays and collections)* in built-in types, other generic class types support using `in` or `out` to modify generic parameters, for example:

|DTO Language Type|Generated Java Type|Generated Kotlin Type|
|-|-|-|
|UserType1&lt;UserType2&gt;|UserType1&lt;UserType2&gt;|UserType1&lt;UserType2&gt;|
|UserType1&lt;out UserType2&gt;|UserType1&lt;? extends UserType2&gt;|UserType1&lt;out UserType2&gt;|
|UserType1&lt;in UserType2&gt;|UserType1&lt;? super UserType2&gt;|UserType1&lt;in UserType2&gt;|

### 11.4 Import Statements  

Except for built-in types, other types must be fully qualified or imported at the beginning of the file when referenced, otherwise they will be considered to belong to the same package as the current entity.

The DTO language supports various styles of import statements, for example:

-   Single class import

    ```
    import java.time.LocalDateTime
    ```

-   Single class renamed import

    ```
    import java.time.LocalDateTime as LDT
    ```

-   Multi-class import

    ```
    import java.time.{
        LocalDateTime,
        OffsetDataTime,
        ZonedDataTime
    }
    ```

-   Multi-class renamed import

    ```
    import java.time.{
        LocalDateTime as LDT,
        OffsetDataTime as ODT,
        ZonedDataTime as ZDT 
    }
    ```

## 12. Annotations

### 12.1 Basic Usage

You can use annotations to decorate DTO types, mapped properties, and custom properties in the DTO language:

```sh title="BookInput.dto"
import org.babyfish.jimmer.client.Doc 
import javax.validation.constraints.Size

@Doc("BookInput without associations") ❶
BookInput {
    
    #allScalars

    @Size(min = 4, max = 20) ❷
    name

    @Size(min = 10, max = 50) ❸
    remark: String
}
```

Where:

-   ❶ Decorates type

-   ❷ Decorates mapped properties  

-   ❸ Decorates custom properties

:::tip
There is a detail to note:
```sh title="BookView"
...import statements omitted...

BookView {

    ...other properties omitted...

    # highlight-next-line
    @A authors @B {
        ...associated object properties omitted... 
    }

    ...other DTO types omitted...
}
```
Where:  

-   `@A` decorates the `authors` property

-   `@B` decorates the anonymous associated type
:::

### 12.2 Annotation Replacement

-   As mentioned above, the DTO language supports annotations to directly control the annotations of the generated DTO types.

-   If a DTO property is not decorated by any annotation, the annotations of the corresponding property in the original entity will be copied *(if the DTO property is mapped, not custom)*.
    Among them, any **non**-jimmer annotations under the `org.babyfish.jimmer.client` package will be copied to the generated DTO type, except for those.

### 12.3 value Parameter

The `value` parameter in annotations can be abbreviated, for example:

```
@UserAnnotation(value = "a", value2 = "b", value3 = "c")
```

can be abbreviated as:

``` 
@UserAnnotation("a", value2 = "b", value3 = "c")
```

Unlike Java, no matter how many parameters an annotation has, the `value` parameter can be abbreviated, as long as the abbreviated property is configured first.

### 12.4 Mixing Java and Kotlin Syntax

There are some subtle differences between Java and Kotlin annotation syntax. The DTO language mixes the features of both, for example:

-   ```
    @UserAnnotation(
        "key1", 
        items = {
            @Item("subKey1", description = "Detail information for subKey1 ..."),
            @Item("subKey2", description = "Detail information for subKey2 ..."),
            @Item("subKey3", description = "Detail information for subKey3 ...")
        }
    )
    ```

-   ```
    @UserAnnotation(
        "key1",
        items = [
            @Item("subKey1", description = "Detail information for subKey1 ..."),
            @Item("subKey2", description = "Detail information for subKey2 ..."),
            @Item("subKey3", description = "Detail information for subKey3 ...")
        ]
    )
    ```

-   ```
    @UserAnnotation(
        "key1",
        items = {
            Item("subKey1", description = "Detail information or subKey1 ..."),
            Item("subKey2", description = "Detail information for subKey2 ..."),
            Item("subKey3", description = "Detail information for subKey3 ...")
        }
    )
    ```

-   ```
    @UserAnnotation(
        "key1",
        items = [
            Item("subKey1", description = "Detail information for subKey1 ..."),
            Item("subKey2", description = "Detail information for subKey2 ..."),
            Item("subKey3", description = "Detail information for subKey3 ...")
        ]
    )
    ```

The above four styles are equivalent. You can freely choose the style you like.  

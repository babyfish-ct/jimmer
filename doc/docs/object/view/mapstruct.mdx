---
sidebar_position: 2
title: MapStruct
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { ShortAssociation } from '@site/src/components/ShortAssociation';
import { ViewMore } from '@site/src/components/ViewMore';

:::caution 
Unless it is to be compatible with existing DTO types in legacy systems, MapStruct is not recommended. [DTO Language](./dto-language) is preferred for the following reasons:

-   Non-negligible development costs

    Jimmer takes dynamic entity objects that can express arbitrary shaped data structures as the core of the system, 
    making the system both convenient and flexible at the same time.

    Therefore, Jimmer's DTO is just an extremely cheap decoration created for compatibility with the existing JVM ecosystem, 
    not the core of the system. Even if needed, the goal is negligible development costs.

    However, manually defining DTOs and using MapStruct for mapping has obvious non-negligible development costs.

-   Can only be used as Input DTO

    The DTO types automatically generated by DTO language have built-in [object fetchers](../../query/object-fetcher). So they can be used as output types of queries, see:
  
    -   [Object Fetcher/DTO Query](../../query/object-fetcher/dto)
    -   [Spring Data/Query DTO](../../spring/repository/dto)

    However, manually defined DTOs mapped with MapStruct do not have corresponding [object fetcher](../../query/object-fetcher) definitions. 
    They only support mutual conversion with dynamic entities. So they are only suitable as Input DTOs, not Output DTOs.

-   Issues when working with Kotlin projects

    -   [Mapstruct](https://mapstruct.org/) is based on `apt` *(Annotation Processor)*. 
    
        So `kapt` needs to be used in Kotlin, which will significantly slow down compilation in Kotlin projects.

    -   Kotlin has deprecated [kapt](https://kotlinlang.org/docs/kapt.html) and advocates using [ksp](https://kotlinlang.org/docs/ksp-overview.html) instead. 
    
        So as Kotlin evolves, using `kapt` may encounter more and more issues in the future.
:::

## Dependencies and Preprocessors

For converting static POJOs to Jimmer dynamic objects, MapStruct does not know how to build Jimmer objects. So

- Jimmer's own preprocessor *(Java's `jimmer-apt` or Kotlin's `jimmer-ksp`)* generates some MapStruct-oriented code in Draft, allowing MapStruct to build Jimmer objects through its [Builder](https://mapstruct.org/documentation/stable/reference/html/#mapping-with-builders) mode.

- Jimmer extends MapStruct's Annotation Processor. This extension allows MapStruct to utilize the capabilities reserved for MapStruct in the generated Draft to build Jimmer objects.

    This extension is called `jimmer-mapstruct-apt`

    - For Java, `jimmer-mapstruct-apt` is included in `jimmer-apt`

    - For Kotlin, `jimmer-ksp` and `jimmer-mapstruct-apt` must be used together in the maven or gradle configuration file

<Tabs groupId="buildTool">
<TabItem value="java_maven" label="Java(Maven)">

```xml title="pom.xml"
...omit other code...

<build>
    <dependencies>
        <dependency> ➀
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
        </dependency>
        <dependency> ➊
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>
        ...omit other dependencies...
    </dependencies>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.10.1</version>
            <configuration>
                <annotationProcessorPaths>
                    <path> ➁
                        <groupId>org.projectlombok</groupId>
                        <artifactId>lombok</artifactId>
                        <version>${lombok.version}</version>
                    </path>
                    <path> ➋
                        <groupId>org.babyfish.jimmer</groupId>
                        <artifactId>jimmer-apt</artifactId>
                        <version>${jimmer.version}</version>
                    </path>
                    <path> ➌
                        <groupId>org.mapstruct</groupId>
                        <artifactId>mapstruct-processor</artifactId>
                        <version>${mapstruct.version}</version>
                    </path>
                </annotationProcessorPaths>
            </configuration>
        </plugin>
    </plugins>
</build>

...omit other code...
```

</TabItem>
<TabItem value="java_gradle" label="Java(Gradle)">

```groovy title="build.gradle"
dependencies {
    
    implementation "org.projectlombok:lombok:${lombok.version}" ➀
    implementation "org.mapstruct:mapstruct:${mapstructVersion}" ➊

    annotationProcessor "org.projectlombok:lombok:${lombok.version}" ➁
    annotationProcessor "org.babyfish.jimmer:jimmer-apt:${jimmerVersion}" ➋
    annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}" ➌

    ...omit other dependencies...
}
```

</TabItem>
<TabItem value="kotin_maven" label="Kotlin(Maven)">

```xml title="pom.xml" 
...omit other code...

<build>
    <sourceDirectory>src/main/kotlin</sourceDirectory>
    <testSourceDirectory>src/test/kotlin</testSourceDirectory>

    <dependencies>
        <dependency> ➊
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>
        ...omit other dependencies...
    </dependencies>

    <plugins>
        <plugin>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-maven-plugin</artifactId>
            <version>${kotlin.version}</version>
            <executions>
                <execution>
                    <id>compile</id>
                    <phase>compile</phase>
                    <goals>
                        <goal>compile</goal>
                    </goals>
                </execution>
                <execution>
                    <id>test-compile</id>
                    <phase>test-compile</phase>
                    <goals>
                        <goal>test-compile</goal>
                    </goals>
                </execution>
            </executions>
            <configuration>
                <compilerPlugins>
                    <compilerPlugin>ksp</compilerPlugin>
                </compilerPlugins>
                <annotationProcessorPaths>
                    <path>
                        <groupId>org.mapstruct</groupId> ➌
                        <artifactId>mapstruct-processor</artifactId>
                        <version>${mapstruct.version}</version>
                    </path>
                    <path>
                        <groupId>org.babyfish.jimmer</groupId> ⓐ
                        <artifactId>jimmer-mapstruct-apt</artifactId>
                        <version>${jimmer.version}</version>
                    </path>
                </annotationProcessorPaths>
            </configuration>
            <dependencies>
                <dependency>
                    <groupId>com.dyescape</groupId>
                    <artifactId>kotlin-maven-symbol-processing</artifactId>
                    <version>1.3</version>
                </dependency>
                <dependency>
                    <groupId>org.babyfish.jimmer</groupId> ➋
                    <artifactId>jimmer-ksp</artifactId>
                    <version>${jimmer.version}</version>
                </dependency>
            </dependencies>
        </plugin>
    </plugins>
</build>

...omit other code...
```

</TabItem>
<TabItem value="kotin_gralde" label="Kotlin(Gradle.kts)">

```kotlin title="build.gradle.kts"
plugins {
    id("com.google.devtools.ksp") version "1.7.10-1.0.6"
    kotlin("kapt") version "1.6.21"

    ...omit other plugins...
}
dependencies {
    
    implementation "org.mapstruct:mapstruct:${mapstructVersion}" ➊

    ksp("org.babyfish.jimmer:jimmer-ksp:${jimmerVersion}") ➋
    kapt("org.mapstruct:mapstruct-processor:${mapstructVersion}") ➌
	kapt("org.babyfish.jimmer:jimmer-mapstruct-apt:${jimmerVersion}") ⓐ

    ...omit other dependencies...
}

kotlin {
    sourceSets.main {
        kotlin.srcDir("build/generated/ksp/main/kotlin")
    }
}
```

</TabItem>
</Tabs>

In this example, we assume static POJOs are written in Java using [lombok](https://projectlombok.org/).

<table>
    <thead>
        <tr>
            <th>Language</th>
            <th>Location</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="3">Java and Kotlin</td>
            <td>➊</td>
            <td>Introduce mapstruct dependency for user code to use mapstruct annotations</td>
        </tr>
        <tr>
            <td>➋</td>
            <td>Use Jimmer's preprocessor to generate related source code for dynamic types, Java uses `jimmer-apt`, Kotlin uses `jimmer-ksp`</td>
        </tr>
        <tr>
            <td>➌</td>
            <td>Use mapstruct's annotation processor to generate source code <i>(introduced later)</i></td>
        </tr>
        <tr>
            <td rowspan="2">Java only</td>
            <td>➀</td>
            <td>Introduce lombok dependency for user code to use lombok annotations</td>
        </tr>
        <tr>
            <td>➁</td>
            <td>Use Lombok preprocessor to modify static POJO class code, e.g. add getters, setters</td>
        </tr>
        <tr>
            <td rowspan="2">Kotlin only</td>
            <td>ⓐ</td>
            <td>Use `jimmer-mapstruct-apt` to extend ➌</td>
        </tr>
    </tbody>
</table>

## Define POJO

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInput.java"
@Data
public class BookInput {

    @Nullable
    private Long id;

    private String name;

    private int edition;

    private BigDecimal price;

    @Nullable
    private Long storeId;

    private List<Long> authorIds;
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInput.java"
data class BookInput(
    val id: Long? = null,
    val name: String,
    val edition: Int,
    val price: BigDecimal,
    val storeId: Long?,
    val authorIds: List<Long>
)
```

</TabItem>
</Tabs>

:::note
The `@Nullable` annotation is used in the Java POJO code only to improve readability and has no functional effect
:::

Three properties of this POJO need to be explained:

-   `BookInput.id`

    - Here, `BookInput.id` is allowed to be null. This is necessary, for example, the id does not need to be specified when inserting data.

    - The dynamic property `Book.id` of the entity object does not allow null *(Jimmer prohibits id from being null, please refer to [Mapping/Basic Mapping/@Id](../../mapping/base/basic#id))*

    The two contradict each other, so how to convert `BookInput` to `Book`?

    :::tip
    Jimmer agrees that if the property of the POJO can be null while the corresponding property of the dynamic object cannot be null, the corresponding property of the dynamic object will not be assigned and will remain missing.
    :::

-   `BookInput.storeId` 

    This is obviously an associated id for the dynamic entity object property `Book.store`. 
    
    This kind of dynamic object property is defined as an associated object, but in the POJO it is defined as an associated id, 
    called a <ViewMore buttonText="short association"><ShortAssociation/></ViewMore>.

-   `BookInput.authorIds` 
    
    This is obviously a collection of associated ids, for the dynamic entity object property `Book.authors`. 
    
    This kind of dynamic object property is defined as an associated objects, but in the POJO it is defined as an associated ids, 
    called a <ViewMore buttonText="short association"><ShortAssociation/></ViewMore>.

The other properties are exactly the same as the original entity definition and need no explanation.

## Define Mapper

The most important thing when using mapstruct is to define the Mapper, as follows

<Tabs groupId="language">
<TabItem value="java" label="Java">  

```java title="BookInputMapper.java"
@Mapper
public interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    Book toBook(BookInput input);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInputMapper.java"  
@Mapper
interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    fun toBook(input: BookInput): Book
}
```

</TabItem>
</Tabs>

This Mapper provides a `toBook` method to convert a `BookInput` object to a `Book` object. 

`BookInput.id`, `BookInput.id`, `BookInput.name` and `BookInput.price` are all non-associated properties that mapstruct can handle well.

:::note
The issue that `BookInput.id` can be null while `Book.id` cannot be null has been discussed before, so it won't be repeated here.
:::

The key is how `BookInput.storeId` and `BookInput.authorIds` should be mapped, which falls into two cases:

-   The entity defines @IdView properties  

-   The entity does not define @IdView properties

### If the entity defines @IdView properties

If the entity type defines `@IdView` properties, for example:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
package com.example.model;

import org.babyfish.jimmer.sql.*;
import org.jetbrains.annotations.Nullable;

@Entity
public interface Book {

    ...omit other properties...

    @ManyToOne
    @Nullable
    BookStore store();

    @ManyToMany
    @JoinTable(
        name = "BOOK_AUTHOR_MAPPING",
        joinColumnName = "BOOK_ID",
        inverseJoinColumnName = "AUTHOR_id"
    )
    List<Author> authors();

    // highlight-next-line
    @IdView // id view of associated object store  
    Long storeId();

    // id view of all objects in associated collection authors
    // highlight-next-line
    @IdView("authors")    
    List<Long> authorIds();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt"
package com.example.model

import org.babyfish.jimmer.sql.*

@Entity
interface Book {

    ...omit other properties...

    @ManyToOne
    val store: BookStore?

    @ManyToMany
    @JoinTable(
        name = "BOOK_AUTHOR_MAPPING",
        joinColumnName = "BOOK_ID",
        inverseJoinColumnName = "AUTHOR_id"
    )
    val authors: List<Auhtor>

    // highlight-next-line
    @IdView // id view of associated object store
    val storeId: Long?

    // id view of all objects in associated collection authors
    // highlight-next-line
    @IdView("authors") 
    val authorIds: List<Long>
}
```

</TabItem>
</Tabs>

In this case, the entity object and POJO correspond completely, and the Mapper does not need any modification.

### If the entity does not define @IdView properties

If the entity type does not define `@IdView` properties, the Mapper needs to be modified:

-   Convert `BookInput.storeId` to a `BookStore` object with only the id, then assign it to `Book.store`

-   Convert `BookInput.authorIds` to a collection of `Author` objects with only ids, then assign it to `Book.authors`

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInputMapper.java"
@Mapper
public interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line
    @Mapping(target = "store", source = "storeId") 
    // highlight-next-line
    @Mapping(target = "authors", source = "authorIds")
    Book toBook(BookInput input);

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    BookStore toBookStore(Long id);

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    Author toAuthor(Long id);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInputMapper.java"
@Mapper
interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line
    @Mapping(target = "store", source = "storeId")
    // highlight-next-line 
    @Mapping(target = "authors", source = "authorIds")
    fun toBook(input: BookInput): Book

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    fun toBookStore(id: Long?): BookStore

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    fun toAuthor(id: Long?): Author
}
```

</TabItem>
</Tabs>

Since mapstruct also supports `@Mapping(target = "store.id", source = "storeId")`, the following syntax can also be used to simplify the code:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInputMapper.java"
@Mapper
public interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line  
    @Mapping(target = "store.id", source = "storeId")
    @Mapping(target = "authors", source = "authorIds")
    Book toBook(BookInput input);

    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = ".")
    Author toAuthor(Long id); 
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInputMapper.java"
@Mapper
interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line
    @Mapping(target = "store.id", source = "storeId") 
    @Mapping(target = "authors", source = "authorIds")
    fun toBook(input: BookInput): Book

    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = ".")
    fun toAuthor(id: Long?): Author
}
```

</TabItem>
</Tabs>

## Usage

Now we can convert `BookInput` to `Book`:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookInput input = ...omit...;
BookInputMapper mapper = Mappers.getMapper(BookInputMapper.class);
Book book = mapper.toBook(input);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
val input: BookInput = ...omit...
val mapper = Mappers.getMapper(BookInputMapper::class.java)
val book = mapper.toBook(input)
```

</TabItem>
</Tabs>

## Make POJO implement Input interface

Jimmer provides a simple interface, `org.babyfish.jimmer.Input<E>`

```java
public interface Input<E> {

    E toEntity(); 
}
```

Dynamic objects will never implement this interface, this interface should be implemented by user-defined static POJO classes. Its function is very simple, just convert the current static POJO to a dynamic object.

This interface can provide convenience at the syntax level. Whether it is the underlying [save command](../../mutation/save-command) or the top-level spring-data base interface `JRepository/KRepository`, its `sava` method directly accepts `Input` parameters, without the user having to call the Mapper to complete the conversion.

If you want this convenience at the syntax level, you can choose to have the POJO implement this interface by modifying the `BookInput` code as follows:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInput.java"  
@Data
public class BookInput implements Input<Book> { ❶

    private static final Converter CONVERTER =  
        Mappers.getMapper(Converter.class);

    ...omit private fields...

    @Override  
    public Book toEntity() { ❷
        return CONVERTER.toBook(this);
    }

    @Mapper
    interface Converter {

        @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
        Book toBook(BookInput input);

        ...omit other mapstruct configuration... 
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInput.kt"
data class BookInput(
    ...omit... 
): Input<Book> { ❶

    override fun toEntity(): Book = ❷
        CONVERTER.toBook(this)

    @Mapper  
    internal interface Converter {  

        @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
        fun toBook(input: BookInput): Book

        ...omit other mapstruct configuration...
    }

    companion object {

        @JvmStatic  
        private val CONVERTER =   
            Mappers.getMapper(Converter::class.java)  
    }
}
```

</TabItem> 
</Tabs>

-   ❶ `BookInput` class implements interface `org.babyfish.jimmer.Input`

-   ❷ Implement `Input.toEntity` method, use MapStruct to convert the current static `Input DTO` object to the dynamic `Book` entity object. This is the only function of this class.
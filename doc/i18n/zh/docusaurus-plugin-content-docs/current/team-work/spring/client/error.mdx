---
sidebar_position: 2
title: 生成前端异常
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

这部分功能其实和ORM没有关系。

然而，既然提供了[前后端API免对接](./api)，那么就必须提供这部分功能，否则就不是一套完整的方案。

## 异常簇

我们需要定义特别的Java/Kotlin业务异常，它们能够被直接翻译成客户端可以理解的数据。

该如何定义这种特别的业务异常类型呢？有两种极端的选择

-   整个应用程序共享一个业务异常类，并内置客户端可以立即的error code

-   每个业务错误都定义一个业务异常类

很明显，上述两种方案都不合适。第一种方案粒度太粗，全局的error code难以维护；第二种方案粒度太细，需要定义的异常类是在太多了。

所以，Jimmer选择折中方案，把业务异常分为多个簇，每个簇用一套Error Code。

Jimmer采用枚举来定义异常簇，枚举也是这簇异常的错误码，例如

### 定义异常簇

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="UserInfoErrorCode.java"
package com.example.business.error;

import org.babyfish.jimmer.error.ErrorFamily;

// highlight-next-line
@ErrorFamily
public enum UserInfoErrorCode {
    ILLEGAL_USER_NAME,
    PASSWORD_TOO_SHORT,
    PASSWORDS_NOT_SAME
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="UserInfoErrorCode.kt"
package com.example.business.error

import org.babyfish.jimmer.error.ErrorFamily

// highlight-next-line
@ErrorFamily
enum class UserInfoErrorCode {
    ILLEGAL_USER_NAME,
    PASSWORD_TOO_SHORT,
    PASSWORDS_NOT_SAME
}
```

</TabItem>
</Tabs>

`@org.babyfish.jimmer.error.ErrorFamily`表示该枚举表示一簇业务异常，该枚举也是这簇异常的ErrorCode.

注解`@ErrorFamily`会被Jimmer的预编译器处理

:::info
这里的预编译器，对于Java而言就是Annotation Processor；对于Kotlin而言就是KSP。

这部分类型已经在[概述/快速上手/生成代码](../../overview/get-started/generate-code)一节中讨论过，此处不在重复。
:::

预编译器会会根据此枚举生成如下异常类

:::info
用作声明异常簇的枚举可以选择用`ErrorCode`或`Error`结尾。

-   如果有这样的特殊结尾，异常类名 = 枚举名去掉这样的结尾并加 + `Exception`

-   否则，异常类名 = 枚举名 + `Exception`

所以，这里生成的异常名为`UserInfoException`
:::

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="UserInfoException.java"
public abstract class UserInfoException 
    extends CodeBasedException { ❶

    private UserInfoException(String message, Throwable cause) {
        super(message, cause);
    }

    @Override
    public abstract UserInfoErrorCode getCode(); ❷

    public static UserInfoException illegalUserName(@NotNull String message) { ❸
        return new IllegalUserName(
            message,
            null
        );
    }

    public static UserInfoException illegalUserName( ❹
            @NotNull String message,
            @Nullable Throwable cause
    ) {
        return new IllegalUserName(
            message,
            cause
        );
    }

    public static UserInfoException passwordTooShort(@NotNull String message) { ❺
        return new PasswordTooShort(
            message,
            null
        );
    }

    public static UserInfoException passwordTooShort( ❻
            @NotNull String message,
            @Nullable Throwable cause
    ) {
        return new PasswordTooShort(
            message,
            cause
        );
    }

    public static UserInfoException passwordsNotSame(@NotNull String message) { ❼
        return new PasswordsNotSame(
            message,
            null
        );
    }

    public static UserInfoException passwordsNotSame( ❽
            @NotNull String message,
            @Nullable Throwable cause
    ) {
        return new PasswordsNotSame(
            message,
            cause
        );
    }

    public static class IllegalUserName extends UserInfoException {
        public IllegalUserName(String message, Throwable cause) {
            super(message, cause);
        }

        @Override
        public UserInfoErrorCode getCode() {
            return UserInfoErrorCode.ILLEGAL_USER_NAME; ❾
        }

        @Override
        public Map<String, Object> getFields() {
            return Collections.emptyMap();
        }
    }

    public static class PasswordTooShort extends UserInfoException {
        public PasswordTooShort(String message, Throwable cause) {
            super(message, cause);
        }

        @Override
        public UserInfoErrorCode getCode() {
            return UserInfoErrorCode.PASSWORD_TOO_SHORT; ❿
        }

        @Override
        public Map<String, Object> getFields() {
            return Collections.emptyMap();
        }
    }

    public static class PasswordsNotSame extends UserInfoException {
        public PasswordsNotSame(String message, Throwable cause) {
            super(message, cause);
        }

        @Override
        public UserInfoErrorCode getCode() {
            return UserInfoErrorCode.PASSWORDS_NOT_SAME; ⓫
        }

        @Override
        public Map<String, Object> getFields() {
            return Collections.emptyMap();
        }
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="UserInfoException.kt"
public abstract class UserInfoException private constructor(
    message: String,
    cause: Throwable? = null,
) : CodeBasedException(message, cause) { ❶

    public abstract override val code: UserInfoErrorCode ❷

    public companion object {
        @JvmStatic
        public fun illegalUserName( ❸❹
            message: String, 
            cause: Throwable? = null
        ): UserInfoException =
            IllegalUserName(
                message,
                cause
            )

        @JvmStatic
        public fun passwordTooShort( ❺❻
            message: String, 
            cause: Throwable? = null
        ): UserInfoException =
            PasswordTooShort(
                message,
                cause
            )

        @JvmStatic
        public fun passwordsNotSame( ❼❽
            message: String, 
            cause: Throwable? = null
            ): UserInfoException =
                PasswordsNotSame(
                    message,
                    cause
                )
    }

    public class IllegalUserName(
        message: String,
        cause: Throwable? = null,
    ) : UserInfoException(message, cause) {

        public override val code: UserInfoErrorCode
            get() = UserInfoErrorCode.ILLEGAL_USER_NAME ❾

        public override val fields: Map<String, Any?>
            get() = emptyMap()
    }

    public class PasswordTooShort(
        message: String,
        cause: Throwable? = null,
    ) : UserInfoException(message, cause) {

        public override val code: UserInfoErrorCode
            get() = UserInfoErrorCode.PASSWORD_TOO_SHORT ❿

        public override val fields: Map<String, Any?>
            get() = emptyMap()
    }

    public class PasswordsNotSame(
        message: String,
        cause: Throwable? = null,
    ) : UserInfoException(message, cause) {

        public override val code: UserInfoErrorCode
            get() = UserInfoErrorCode.PASSWORDS_NOT_SAME ⓫

        public override val fields: Map<String, Any?>
            get() = emptyMap()
    }
}
```

</TabItem>
</Tabs>

-   ❶ 基于枚举错误码的异常必然继承`org.babyfish.jimmer.error.CodeBasedException`

-   ❷ 这一簇异常的错误码的类型为`UserInfoErrorCode`

-   ❸❹ 构建错误码为`ILLEGAL_USER_NAME`的异常的静态方法

-   ❺❻ 构建错误码为`PASSWORD_TOO_SHORT`的异常的静态方法

-   ❼❽ 构建错误码为`PASSWORDS_NOT_SAME`的异常的静态方法

-   ❾ 异常类`UserInfoException.IllegalUserName`的错误码为`ILLEGAL_USER_NAME`

-   ❿ 异常类`UserInfoException.PasswordTooShort`的错误码为`PASSWORD_TOO_SHORT`

-   ⓫ 异常类`UserInfoException.PasswordsNotSame`的错误码为`PASSWORDS_NOT_SAME`

### 为异常码添加字段

可以为任何一个错误码添加附加字段。

比如，`ILLEGAL_USER_NAME`表示非法的用户名，即用户名包含了非法字符。我们可以为其添加字段`illegalChars`

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="UserInfoErrorCode.java"
@ErrorFamily
public enum UserInfoErrorCode {

    // highlight-next-line
    @ErrorField(name = "illegalChars", type = Character.class, list = true)
    ILLEGAL_USER_NAME,
    
    PASSWORD_TOO_SHORT,

    PASSWORDS_NOT_SAME
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="UserInfoErrorCode.kt"
@ErrorFamily
enum class UserInfoErrorCode {
    
    // highlight-next-line
    @ErrorField(name = "illegalChars", type = Char::class, list = true)
    ILLEGAL_USER_NAME,

    PASSWORD_TOO_SHORT,
    
    PASSWORDS_NOT_SAME
}
```

</TabItem>
</Tabs>

生成的代码的如下

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="UserInfoException.java"
public abstract class UserInfoException extends CodeBasedException {

    public static UserInfoException illegalUserName(
        @NotNull String message,
        // highlight-next-line
        @NotNull List<Character> illegalChars
    ) {
        ...省略代码...
    }

    public static UserInfoException illegalUserName(
        @NotNull String message,
        @Nullable Throwable cause, 
        // highlight-next-line
        @NotNull List<Character> illegalChars
    ) {
        ...省略代码...
    }

    public static class IllegalUserName extends UserInfoException {

        @NotNull
        private final List<Character> illegalChars;

        public IllegalUserName(
            String message, 
            Throwable cause,
            // highlight-next-line
            @NotNull List<Character> illegalChars
        ) {
            super(message, cause);
            this.illegalChars = illegalChars;
        }

        @Override
        public Map<String, Object> getFields() {
            // highlight-next-line
            return Collections.singletonMap("illegalChars", illegalChars);
        }

        @NotNull
        public List<Character> getIllegalChars() {
            // highlight-next-line
            return illegalChars;
        }

        ...省略其他代码...
    }

    ...省略其他代码...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="UserInfoException.kt"
public abstract class UserInfoException private constructor(
    message: String,
    cause: Throwable? = null,
) : CodeBasedException(message, cause) { ❶

    public abstract override val code: UserInfoErrorCode ❷

    public companion object {
        
        @JvmStatic
        public fun illegalUserName(
            message: String,
            cause: Throwable? = null,
            // highlight-next-line
            illegalChars: List<Char>,
        ): UserInfoException = 
            ...省略代码...

        ...省略其他代码...
    }

    public class IllegalUserName(
        message: String,
        cause: Throwable? = null,
        // highlight-next-line
        public val illegalChars: List<Char>,
    ) : UserInfoException(message, cause) {

        public override val fields: Map<String, Any?>
            get() = mapOf(
                // highlight-next-line
                "illegalChars" to illegalChars
            )

        ...省略其他代码...
    }
}
```

</TabItem>
</Tabs>

## 为REST API声明异常

### 允许抛出异常簇中所有异常

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="UserController.java"
package com.example.service;

import org.babyfish.jimmer.client.ThrowsAll;

@PostMapping("/user")
// highlight-next-line
@ThrowsAll(UserInfoErrorCode.class)
public void registerUser(@RequestBody RegisterUserInput input) {
    ...省略代码...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="UserController.kt"
package com.example.service

import import org.babyfish.jimmer.client.ThrowsAll

@PostMapping("/user")
// highlight-next-line
@ThrowsAll(UserInfoErrorCode::class)
fun registerUser(@RequestBody input: RegisterUserInput) {
    ...省略代码...
}
```

</TabItem>
</Tabs>

:::info
注解`@org.babyfish.jimmer.client.ThrowsAll`允许REST API抛出异常簇中所有异常。
:::

### 允许抛出异常簇中部分异常

让我定位另外一个业务异常簇

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="PlatformErrorCode.java"
@ErrorFamily
public enum PlatformErrorCode {
    PERMISSION_DENIED,
    DATA_IS_FROZEN,
    SERVICE_IS_SUSPENDED,
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="PlatformErrorCode.kt"
@ErrorFamily
enum class PlatformErrorCode {
    PERMISSION_DENIED,
    DATA_IS_FROZEN,
    SERVICE_IS_SUSPENDED
}
```

</TabItem>
</Tabs>

为了能声明某个REST API只能抛出这簇异常中的部分异常，定义如下注解

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="ThrowsPlatformError.java"
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ThrowsPlatformError {
    PlatformErrorCode[] value();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="ThrowsPlatformError.kt"
@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION)
annotation class ThrowsPlatformError(
    val value: Array<PlatformErrorCode>
)
```

</TabItem>
</Tabs>

这个注解满足以下5个条件

-   `Retention`被配置为`RUNTIME`，即运行时可反射

-   `Target`被配置为`METHOD`或`FUNCTION` *(kotlin)*，可以用于修饰方法

-   具备一个名称为`value`的属性

-   `value`属性的类型为数组

-   `value`数组的元素类型时被`@ErrorFamily`修饰的枚举。

:::tip
如果一个注解满足以上所有条件时，就可以用它修饰REST API，为其声明所抛出的异常。就如同我们使用`@ThrowsAll`那样
:::

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="UserController.java"
@PostMapping("/user")
@ThrowsAll(UserInfoErrorCode.class)
// highlight-next-line
@ThrowsPlatformError({PlatformErrorCode.SERVICE_IS_SUSPENDED})
public void registerUser(@RequestBody RegisterUserInput input) {
    ...省略代码...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="UserController.kt"
@PostMapping("/user")
@ThrowsAll(UserInfoErrorCode::class)
// highlight-next-line
@ThrowsPlatformError([PlatformErrorCode.SERVICE_IS_SUSPENDED])
fun registerUser(@RequestBody input: RegisterUserInput) {
    ...省略代码...
}
```

</TabItem>
</Tabs>

## 导出服务端异常

前面的工作只是声明REST API有可能抛出何种异常。接下来我们讨论在服务端真正抛出异常

### 抛出异常

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="UserController.java"
@PostMapping("/user")
@ThrowsAll(UserInfoErrorCode.class)
@ThrowsPlatformError({PlatformErrorCode.SERVICE_IS_SUSPENDED})
public void registerUser(@RequestBody RegisterUserInput input) {
    if (...某些条件...) {
        // highlight-next-line
        throw PlatformException.serviceIsSuspended(
            "The service is suspended"
        );
    }
    ...省略其他代码...
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="UserController.kt"
@PostMapping("/user")
@ThrowsAll(UserInfoErrorCode::class)
@ThrowsPlatformError([PlatformErrorCode.SERVICE_IS_SUSPENDED])
fun registerUser(@RequestBody input: RegisterUserInput) {
    if (...某些条件...) {
        // highlight-next-line
        throw PlatformException.serviceIsSuspended(
            "The service is suspended"
        )
    }
    ...省略其他代码...
}
```

</TabItem>
</Tabs>

:::caution
内部代码抛出的异常的种类，不得超过对外声明的种类
:::

### 将异常消息写入HTTP响应

:::warning
下个版本这部分会自动化，这里象征性给出Java代码即可
:::

```java
@ControllerAdvice
public class CodeBasedExceptionAdvice {

    @ExceptionHandler
    public ResponseEntity<ExportedError> handle(CodeBasedException ex) {
        return new ResponseEntity<>(ex.getExportedError(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

## 客户端

### 生成的TypeScript代码

```ts
export type AllErrors = ❶
    {
        readonly family: "PlatformErrorCode", ❷
        readonly code: "SERVICE_IS_SUSPENDED" ❸
    } | 
    {
        readonly family: "UserInfoErrorCode",
        readonly code: "ILLEGAL_USER_NAME",
        readonly "illegalChars": ReadonlyArray<number> ❹
    } | 
    {
        readonly family: "UserInfoErrorCode",
        readonly code: "PASSWORDS_NOT_SAME"
    } | 
    {
        readonly family: "UserInfoErrorCode",
        readonly code: "PASSWORD_TOO_SHORT"
    } |
    ...省略其他代码...
;

export type ApiErrors = { ❺
    "userController": { ❻
        "registerUser": AllErrors & ( ❼
            {
                readonly family: 'UserInfoErrorCode',
                readonly code: 'ILLEGAL_USER_NAME',
                readonly [key:string]: any
            } | 
            {
                readonly family: 'UserInfoErrorCode',
                readonly code: 'PASSWORD_TOO_SHORT',
                readonly [key:string]: any
            } | 
            {
                readonly family: 'UserInfoErrorCode',
                readonly code: 'PASSWORDS_NOT_SAME',
                readonly [key:string]: any
            } | 
            {
                readonly family: 'PlatformErrorCode',
                readonly code: 'SERVICE_IS_SUSPENDED',
                readonly [key:string]: any
            }
        ),
        ...省略其他代码...
    },
    "bookController": {
        ...省略代码...
    },
    ...省略其他代码...
};
```

-   ❶ `AllErrors`定义所有错误类型

    :::cuation
    只有REST API使用注解明确声明会被抛出错误码才会被用于生成TypeScript代码。
    
    比如，上文中我们使用Java/Kotlin代码定义了错误码`PlatformError.PERMISSION_DENIED`和`PlatformErrorCode.DATA_IS_FROZEN`，
    但它们暂未被被任何REST API使用`@ThrowsAll`或自定义的`@ThrowsPlatformError`声明。所以，它们不会在`AllErrors`中被定义。
    :::

-   ❷ 被`@ErrorFamily`修饰的枚举名，在客户端代码中是错误的`family`字段。用于鉴别错误属于哪一簇

-   ❸ 枚举变量的名字，在客户端代码中是错误的`code`字段。用于鉴别错误是哪一种

-   ❹ 服务端使用`@ErrorField` *(此注解可以重复)* 为某个错误码声明任意个附加字段 *(本例只有一个)*，因此，这里生成所有附加字段

    :::tip
    ❶处的`AllErrors`定义所有错误，绝不重复。
    
    稍后❺处的`ApiErrors`引用错误，可能重复。因为不同的REST API可能都会被声明未抛出同一种错误码。

    所以，附加字段总是被声明在`AllErrors`中，不会被声明再`ApiErrors`中。这也是`AllErrors`和`ApiErrors`分离的根本原因。
    :::

-   ❺ 各REST API可能抛出的错误

-   ❻ `userController`模块可能抛出的错误

-   ❼ `userController.registerUser`接口可能抛出的错误

### TypeScript IDE的效果

上面的TypeScript代码较多，考虑到部分读者没有TypeScript的背景知识，这里罗列一些IDE的智能提示截图

-   全局类型`ApiErrors`下面有两个选项: `userController`和`bookController`

    ![module](@site/static/img/vs-code/module.jpeg)

-   `ApiErrors["userController"]`下面有三个选项: `login`、`logout`和`registerUser`

    ![api](@site/static/img/vs-code/api.jpeg)

-   `ApiErrors["userController"]["registerUser"]`的`family`字段有两个选项: `UserInfoErrorCode`和`PlatformErrorCode`

    ![family](@site/static/img/vs-code/family.jpeg)

-   一旦`family`被确定为`UserInfoErrorCode`，`code`字段有三个选项: `ILLEGAL_USER_NAME`、`PASSWORD_TOO_SHORT`和`PASSWORDS_NOT_SAME`

    ![api](@site/static/img/vs-code/code.jpeg)

-   一旦`code`被确定为`ILLEGAL_USER_NAME`，则可以使用`illegalChars`附加字段   

    ![field](@site/static/img/vs-code/field.jpeg)
